Below are **correct, production-safe patterns** to add an **integer primary key** to an **existing PostgreSQL table**, with guidance on **locking, downtime, and concurrency**.

---

## Case 1 — Table has **no primary key** (most common)

### Step 1: Add the column (no table rewrite)

```sql
ALTER TABLE public.your_table
ADD COLUMN id integer;
```

This is fast and takes only a brief metadata lock.

---

### Step 2: Populate existing rows

Use a sequence so values are unique and deterministic.

```sql
CREATE SEQUENCE public.your_table_id_seq OWNED BY public.your_table.id;

UPDATE public.your_table
SET id = nextval('public.your_table_id_seq')
WHERE id IS NULL;
```

---

### Step 3: Prevent future NULLs

```sql
ALTER TABLE public.your_table
ALTER COLUMN id SET NOT NULL;
```

---

### Step 4: Add the primary key (blocking operation)

```sql
ALTER TABLE public.your_table
ADD CONSTRAINT your_table_pkey PRIMARY KEY (id);
```

⚠️ This step **locks the table** while the index is built.

---

### Step 5: Set default for new rows

```sql
ALTER TABLE public.your_table
ALTER COLUMN id SET DEFAULT nextval('public.your_table_id_seq');
```

---

## Case 2 — Large or hot table (minimal blocking)

For busy tables, build the index **concurrently**.

### 1) Add column + populate (same as above)

### 2) Create unique index concurrently

```sql
CREATE UNIQUE INDEX CONCURRENTLY your_table_id_uidx
ON public.your_table (id);
```

This does **not** block reads/writes.

---

### 3) Attach the index as primary key (short lock)

```sql
ALTER TABLE public.your_table
ADD CONSTRAINT your_table_pkey
PRIMARY KEY USING INDEX your_table_id_uidx;
```

The lock here is brief (metadata only).

---

## Case 3 — You want `SERIAL` / `IDENTITY` semantics

### PostgreSQL 10+

Preferred modern syntax:

```sql
ALTER TABLE public.your_table
ADD COLUMN id integer GENERATED BY DEFAULT AS IDENTITY;
```

Populate existing rows:

```sql
UPDATE public.your_table
SET id = DEFAULT
WHERE id IS NULL;
```

Then:

```sql
ALTER TABLE public.your_table
ALTER COLUMN id SET NOT NULL;

ALTER TABLE public.your_table
ADD CONSTRAINT your_table_pkey PRIMARY KEY (id);
```

---

## Case 4 — Table already has data with duplicates (failure mode)

If any duplicates exist, Step 4 will fail. Detect early:

```sql
SELECT id, COUNT(*)
FROM public.your_table
GROUP BY id
HAVING COUNT(*) > 1;
```

Fix before proceeding.

---

## Locking & performance summary

| Step                      | Blocking            |
| ------------------------- | ------------------- |
| ADD COLUMN                | minimal             |
| UPDATE populate           | row-level           |
| CREATE INDEX CONCURRENTLY | non-blocking        |
| ADD PRIMARY KEY           | short metadata lock |

---

## Best practice recommendation

* Use **IDENTITY** (not `SERIAL`) for new systems
* For existing large tables: **concurrent index → attach PK**
* Name the constraint explicitly (important for replication tooling)

---

## One-shot example (busy production table)

```sql
ALTER TABLE public.your_table ADD COLUMN id integer;

CREATE SEQUENCE public.your_table_id_seq OWNED BY public.your_table.id;

UPDATE public.your_table
SET id = nextval('public.your_table_id_seq')
WHERE id IS NULL;

ALTER TABLE public.your_table ALTER COLUMN id SET NOT NULL;

CREATE UNIQUE INDEX CONCURRENTLY your_table_id_uidx
ON public.your_table (id);

ALTER TABLE public.your_table
ADD CONSTRAINT your_table_pkey PRIMARY KEY USING INDEX your_table_id_uidx;

ALTER TABLE public.your_table
ALTER COLUMN id SET DEFAULT nextval('public.your_table_id_seq');
```

---

If you tell me:

* PostgreSQL version
* Table size (rows)
* Whether the table is actively written to

I can optimize this further (e.g., batching updates, avoiding long transactions, or aligning with logical replication requirements).
